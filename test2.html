<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶ç²’å­æ˜Ÿçƒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff8c42;
            font-size: 24px;
            text-align: center;
            z-index: 100;
            text-shadow: 0 0 20px #ff8c42;
        }

        #video {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border: 2px solid #ff8c42;
            border-radius: 8px;
            z-index: 50;
            display: none;
        }

        #gesture-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            background: rgba(255, 140, 66, 0.2);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ff8c42;
            z-index: 50;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="loading">
            <div>ğŸŒ ç²’å­æ˜ŸçƒåŠ è½½ä¸­...</div>
            <div style="font-size: 14px; margin-top: 10px;">è¯·å…è®¸æ‘„åƒå¤´è®¿é—®ä»¥å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</div>
        </div>
        <video id="video" autoplay muted></video>
        <div id="gesture-info">
            <div>æ‰‹åŠ¿æ§åˆ¶è¯´æ˜ï¼š</div>
            <div>â€¢ æ—‹è½¬æ‰‹æŒ â†’ æ—‹è½¬æ˜Ÿçƒ</div>
            <div>â€¢ æ¡æ‹³åæ‹‰ â†’ æ‹‰è¿œè§†è§’</div>
            <div>â€¢ å¼ æ‰‹å‰ä¼¸ â†’ æ‹‰è¿‘è§†è§’</div>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <!-- MediaPipe Hands CDN - ä¿®æ­£åçš„é“¾æ¥ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>

    <!-- ä¿®æ­£åçš„ CDN é“¾æ¥ (å»æ‰ç‰ˆæœ¬å·) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let planetParticles, innerRingParticles, outerRingParticles;
        let clock = new THREE.Clock();
        let handTracker = null;
        let videoElement = null;
        let gestureState = {
            isDetecting: false,
            handRotation: 0,
            handDistance: 0.5,
            isFist: false,
            isOpenHand: false,
            lastHandDistance: 0.5,
            targetCameraDistance: 15,
            currentCameraDistance: 15,
            targetRotation: 0,
            currentRotation: 0
        };

        // é…ç½®å‚æ•°
        const CONFIG = {
            MIN_CAMERA_DISTANCE: 5,
            MAX_CAMERA_DISTANCE: 50,
            ZOOM_SENSITIVITY: 15,
            ROTATION_SENSITIVITY: 2,
            FIST_THRESHOLD: 0.08,
            OPEN_HAND_THRESHOLD: 0.15,
            SMOOTH_FACTOR: 0.1
        };

        // åˆå§‹åŒ–åœºæ™¯
        function initScene() {
            scene = new THREE.Scene();

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, gestureState.currentCameraDistance);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xff6600, 0.3);
            scene.add(ambientLight);

            // ç‚¹å…‰æºï¼ˆæ¨¡æ‹Ÿé˜³å…‰ï¼‰
            const pointLight = new THREE.PointLight(0xffaa44, 2, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // åˆ›å»ºç²’å­æ˜Ÿçƒ
            createParticlePlanet();

            // åˆ›å»ºç¯ç»•ç²’å­ç¯
            createOrbitingRings();

            // éšè—åŠ è½½æç¤º
            document.getElementById('loading').style.display = 'none';
        }

        // åˆ›å»ºç²’å­æ˜Ÿçƒ
        function createParticlePlanet() {
            const particleCount = 15000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // ä½¿ç”¨çƒå½¢åˆ†å¸ƒ
                const radius = Math.random() * 1.2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);

                // é¢œè‰²æ¸å˜ï¼ˆæ©™è‰²ç³»ï¼‰
                const intensity = Math.random();
                color.setHSL(0.08 + Math.random() * 0.05, 0.9, 0.4 + intensity * 0.4);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;

                // å¤§å°å˜åŒ–
                sizes[i] = 0.02 + Math.random() * 0.08;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            planetParticles = new THREE.Points(geometry, material);
            scene.add(planetParticles);
        }

        // åˆ›å»ºç¯ç»•ç²’å­ç¯
        function createOrbitingRings() {
            // å†…å±‚ç¯
            const innerRingCount = 8000;
            const innerGeometry = new THREE.BufferGeometry();
            const innerPositions = new Float32Array(innerRingCount * 3);
            const innerColors = new Float32Array(innerRingCount * 3);

            for (let i = 0; i < innerRingCount; i++) {
                const i3 = i * 3;
                const radius = 2 + Math.random() * 1;
                const theta = Math.random() * Math.PI * 2;
                const phi = (Math.random() - 0.5) * Math.PI * 0.3;

                innerPositions[i3] = radius * Math.cos(theta);
                innerPositions[i3 + 1] = radius * Math.sin(phi);
                innerPositions[i3 + 2] = radius * Math.sin(theta);

                // ç™½è‰²ç²’å­
                const brightness = 0.8 + Math.random() * 0.2;
                innerColors[i3] = brightness;
                innerColors[i3 + 1] = brightness;
                innerColors[i3 + 2] = brightness;
            }

            innerGeometry.setAttribute('position', new THREE.BufferAttribute(innerPositions, 3));
            innerGeometry.setAttribute('color', new THREE.BufferAttribute(innerColors, 3));

            const innerMaterial = new THREE.PointsMaterial({
                size: 0.03,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.7,
                sizeAttenuation: true
            });

            innerRingParticles = new THREE.Points(innerGeometry, innerMaterial);
            scene.add(innerRingParticles);

            // å¤–å±‚ç¯
            const outerRingCount = 12000;
            const outerGeometry = new THREE.BufferGeometry();
            const outerPositions = new Float32Array(outerRingCount * 3);
            const outerColors = new Float32Array(outerRingCount * 3);

            for (let i = 0; i < outerRingCount; i++) {
                const i3 = i * 3;
                const radius = 3.5 + Math.random() * 1.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = (Math.random() - 0.5) * Math.PI * 0.4;

                outerPositions[i3] = radius * Math.cos(theta);
                outerPositions[i3 + 1] = radius * Math.sin(phi);
                outerPositions[i3 + 2] = radius * Math.sin(theta);

                const brightness = 0.7 + Math.random() * 0.3;
                outerColors[i3] = brightness;
                outerColors[i3 + 1] = brightness;
                outerColors[i3 + 2] = brightness;
            }

            outerGeometry.setAttribute('position', new THREE.BufferAttribute(outerPositions, 3));
            outerGeometry.setAttribute('color', new THREE.BufferAttribute(outerColors, 3));

            const outerMaterial = new THREE.PointsMaterial({
                size: 0.025,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });

            outerRingParticles = new THREE.Points(outerGeometry, outerMaterial);
            scene.add(outerRingParticles);
        }

        // åˆå§‹åŒ–MediaPipeæ‰‹åŠ¿è¯†åˆ«
        async function initMediaPipe() {
            videoElement = document.getElementById('video');

            // è·å–æ‘„åƒå¤´
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 }
            });
            videoElement.srcObject = stream;
            videoElement.play();

            // æ˜¾ç¤ºè§†é¢‘é¢„è§ˆ
            document.getElementById('video').style.display = 'block';

            // åˆå§‹åŒ–MediaPipe Hands
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5,
                selfieMode: true
            });

            hands.onResults(handleGestureResults);

            // ä½¿ç”¨Camera Utils
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });

            camera.start();
            gestureState.isDetecting = true;
        }

        // å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
        function handleGestureResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                gestureState.isFist = false;
                gestureState.isOpenHand = false;
                return;
            }

            const landmarks = results.multiHandLandmarks[0];
            analyzeHandGesture(landmarks);
        }

        // åˆ†ææ‰‹åŠ¿
        function analyzeHandGesture(landmarks) {
            // è®¡ç®—æ‰‹æŒä¸­å¿ƒ
            const palmCenter = {
                x: landmarks[0].x,
                y: landmarks[0].y,
                z: landmarks[0].z
            };

            // è®¡ç®—æ‰‹è…•åˆ°é£ŸæŒ‡çš„å‘é‡ï¼ˆç”¨äºæ—‹è½¬æ£€æµ‹ï¼‰
            const wrist = landmarks[0];
            const indexFinger = landmarks[8];
            const middleFinger = landmarks[12];

            // è®¡ç®—æ‰‹éƒ¨æ—‹è½¬è§’åº¦ï¼ˆå›´ç»•Yè½´ï¼‰
            const dx = indexFinger.x - wrist.x;
            const dz = indexFinger.z - wrist.z;
            gestureState.handRotation = Math.atan2(dx, dz);

            // æ£€æµ‹æ˜¯å¦æ¡æ‹³
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];

            // è®¡ç®—æŒ‡å°–åˆ°æ‰‹æŒä¸­å¿ƒçš„è·ç¦»
            const thumbDist = Math.sqrt(
                Math.pow(thumbTip.x - palmCenter.x, 2) +
                Math.pow(thumbTip.y - palmCenter.y, 2)
            );

            const fingerDist = Math.sqrt(
                Math.pow(indexTip.x - palmCenter.x, 2) +
                Math.pow(indexTip.y - palmCenter.y, 2)
            );

            // åˆ¤æ–­æ‰‹åŠ¿ç±»å‹
            gestureState.isFist = thumbDist < CONFIG.FIST_THRESHOLD && fingerDist < CONFIG.FIST_THRESHOLD;
            gestureState.isOpenHand = thumbDist > CONFIG.OPEN_HAND_THRESHOLD && fingerDist > CONFIG.OPEN_HAND_THRESHOLD;

            // è®¡ç®—æ‰‹åˆ°æ‘„åƒå¤´çš„è·ç¦»ï¼ˆç”¨äºç¼©æ”¾ï¼‰
            gestureState.lastHandDistance = gestureState.handDistance;
            gestureState.handDistance = Math.abs(wrist.z);

            // æ›´æ–°ç›¸æœºç›®æ ‡è·ç¦»
            if (gestureState.isFist) {
                // æ¡æ‹³å¹¶æ‹‰è¿œï¼šç›¸æœºè¿œç¦»
                const distanceChange = (gestureState.handDistance - gestureState.lastHandDistance) * CONFIG.ZOOM_SENSITIVITY;
                gestureState.targetCameraDistance = Math.max(
                    CONFIG.MIN_CAMERA_DISTANCE,
                    Math.min(CONFIG.MAX_CAMERA_DISTANCE, gestureState.targetCameraDistance + distanceChange)
                );
            } else if (gestureState.isOpenHand) {
                // å¼ æ‰‹å¹¶é è¿‘ï¼šç›¸æœºé è¿‘
                const distanceChange = (gestureState.lastHandDistance - gestureState.handDistance) * CONFIG.ZOOM_SENSITIVITY * 0.8;
                gestureState.targetCameraDistance = Math.max(
                    CONFIG.MIN_CAMERA_DISTANCE,
                    Math.min(CONFIG.MAX_CAMERA_DISTANCE, gestureState.targetCameraDistance - distanceChange)
                );
            }

            // æ›´æ–°æ—‹è½¬ç›®æ ‡
            gestureState.targetRotation = -gestureState.handRotation * CONFIG.ROTATION_SENSITIVITY;
        }

        // æ›´æ–°ç›¸æœº
        function updateCamera() {
            // å¹³æ»‘æ’å€¼ç›¸æœºè·ç¦»
            const distanceDiff = gestureState.targetCameraDistance - gestureState.currentCameraDistance;
            const distanceSpeed = Math.abs(distanceDiff) * CONFIG.SMOOTH_FACTOR;
            gestureState.currentCameraDistance += distanceDiff * distanceSpeed;

            // å¹³æ»‘æ’å€¼æ—‹è½¬
            const rotationDiff = gestureState.targetRotation - gestureState.currentRotation;
            const rotationSpeed = Math.abs(rotationDiff) * CONFIG.SMOOTH_FACTOR;
            gestureState.currentRotation += rotationDiff * rotationSpeed;

            // è®¾ç½®ç›¸æœºä½ç½®ï¼ˆå›´ç»•æ˜Ÿçƒæ—‹è½¬ï¼‰
            const radius = gestureState.currentCameraDistance;
            camera.position.x = Math.sin(gestureState.currentRotation) * radius;
            camera.position.z = Math.cos(gestureState.currentRotation) * radius;
            camera.position.y = Math.sin(gestureState.currentRotation * 0.2) * radius * 0.3;

            // ç›¸æœºå§‹ç»ˆçœ‹å‘æ˜Ÿçƒä¸­å¿ƒ
            camera.lookAt(0, 0, 0);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // æ›´æ–°ç›¸æœº
            updateCamera();

            // æ˜Ÿçƒè‡ªè½¬
            if (planetParticles) {
                planetParticles.rotation.y += delta * 0.05;
                planetParticles.rotation.x += delta * 0.02;
            }

            // ç¯ç»•ç²’å­ç¯æ—‹è½¬
            if (innerRingParticles) {
                innerRingParticles.rotation.y += delta * 0.3;
                innerRingParticles.rotation.x = Math.sin(elapsedTime * 0.5) * 0.1;
            }

            if (outerRingParticles) {
                outerRingParticles.rotation.y -= delta * 0.15;
                outerRingParticles.rotation.z = Math.cos(elapsedTime * 0.3) * 0.05;
            }

            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åˆå§‹åŒ–åº”ç”¨
        async function init() {
            try {
                // åˆå§‹åŒ–3Dåœºæ™¯
                initScene();

                // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                await initMediaPipe();

                // å¼€å§‹åŠ¨ç”»å¾ªç¯
                animate();

                // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', onWindowResize);

            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff4444;">åˆå§‹åŒ–å¤±è´¥</div>
                    <div style="font-size: 14px; margin-top: 10px;">è¯·ç¡®ä¿å…è®¸æ‘„åƒå¤´è®¿é—®</div>
                `;
            }
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>